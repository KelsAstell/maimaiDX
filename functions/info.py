from re import Match
from typing import Dict

from .best_50 import *
from .api import *
from .music import Music, download_music_pictrue, mai, RaMusic
from .random_reply import *

with open(os.path.join(static,'abstract_reply.json'), 'r', encoding='utf-8') as f:
    abstract_list = json.load(f)

SONGS_PER_PAGE = 25
level_labels = ['ç»¿', 'é»„', 'çº¢', 'ç´«', 'ç™½']
game_names = ['éŸ³ä¹ä¸–ç•Œ','å†°ä¸ç«','è‡ªå·±','å¤æ ‘æ—‹å¾‹','ä¸­äºŒèŠ‚å¥','èˆç«‹æ–¹Show','eèˆæˆå','è·³èˆçš„çº¿','æ“ç›˜å­','è‰¾æ–¯','æ¨è¾£å­','Arcaea','Dynamix','hso..å‘¸, osu!', 'KohaD','Beatmania IIDX','jubeat','å¤ªé¼“è¾¾äºº','WACCA','å–µæ–¯å¿«è·‘','åŒæ­¥éŸ³å¾‹å–µèµ›å…‹', 'Phi','èŠ‚å¥å¤§å¸ˆ']
realAchievementList = {}
for acc in [i / 10 for i in range(10, 151)]:
    realAchievementList[f'{acc:.1f}'] = generateAchievementList(acc)
plate_to_version = {
    'åˆ': 'maimai',
    'çœŸ': 'maimai PLUS',
    'è¶…': 'maimai GreeN',
    'æª„': 'maimai GreeN PLUS',
    'æ©™': 'maimai ORANGE',
    'æš': 'maimai ORANGE PLUS',
    'æ™“': 'maimai ORANGE PLUS',
    'æ¡ƒ': 'maimai PiNK',
    'æ«»': 'maimai PiNK PLUS',
    'æ¨±': 'maimai PiNK PLUS',
    'ç´«': 'maimai MURASAKi',
    'è«': 'maimai MURASAKi PLUS',
    'å ‡': 'maimai MURASAKi PLUS',
    'ç™½': 'maimai MiLK',
    'é›ª': 'MiLK PLUS',
    'è¼': 'maimai FiNALE',
    'è¾‰': 'maimai FiNALE',
    'ç†Š': 'maimai ã§ã‚‰ã£ãã™',
    'è¯': 'maimai ã§ã‚‰ã£ãã™ PLUS',
    'å': 'maimai ã§ã‚‰ã£ãã™ PLUS',
    'çˆ½': 'maimai ã§ã‚‰ã£ãã™ Splash',
    'ç…Œ': 'maimai ã§ã‚‰ã£ãã™ Splash PLUS',
    'å®™': 'maimai ã§ã‚‰ã£ãã™ UNiVERSE',
    'æ˜Ÿ': 'maimai ã§ã‚‰ã£ãã™ UNiVERSE PLUS',
    'fes': 'maimai ã§ã‚‰ã£ãã™ FESTiVAL',
    'fesp': 'maimai ã§ã‚‰ã£ãã™ FESTiVAL PLUS'
}

maimaidir = os.path.join(static, 'mai', 'pic')

SIYUAN = os.path.join(static, 'SourceHanSansSC-Bold.otf')
TBFONT = os.path.join(static, 'Torus SemiBold.otf')
category = {
    'æµè¡Œ&åŠ¨æ¼«': 'anime',
    'èˆèŒ': 'maimai',
    'niconico & VOCALOID': 'niconico',
    'ä¸œæ–¹Project': 'touhou',
    'å…¶ä»–æ¸¸æˆ': 'game',
    'ç»¿æ´²è®¡åˆ’': 'oasis',
    'homo': 'homo',
    'éŸ³å‡»&ä¸­äºŒèŠ‚å¥': 'ongeki'
}
ABSTRACT_REPLY = os.path.join(static, 'abstract_reply.json')
with open(ABSTRACT_REPLY, 'r', encoding='utf-8') as fp:
    abstract_reply = json.load(fp)
nls_data = ["æˆ‘è¶…ï¼Œ","wocï¼Œ","å¥½è€¶ï¼Œ","6ï¼Œ"]


async def draw_music_info(music: Music):
    im = Image.open(os.path.join(maimaidir, 'music_bg.png')).convert('RGBA')
    genre = Image.open(os.path.join(maimaidir, f'music-{category[music.basic_info.genre]}.png'))
    cover = Image.open(await download_music_pictrue(music.id)).resize((360, 360))
    ver = Image.open(os.path.join(maimaidir, f'{music.type}.png')).resize((94, 35))
    line = Image.new('RGBA', (400, 2), (255, 255, 255, 255))

    im.alpha_composite(genre, (150, 170))
    im.alpha_composite(cover, (170, 260))
    im.alpha_composite(ver, (435, 585))
    im.alpha_composite(line, (150, 710))

    dr = ImageDraw.Draw(im)
    tb = DrawText(dr, TBFONT)
    sy = DrawText(dr, SIYUAN)

    tb.draw(200, 195, 24, music.id, anchor='mm')
    sy.draw(410, 195, 22, music.basic_info.genre, anchor='mm')
    sy.draw_partial_opacity(350, 660, 30, music.title, 1, anchor='mm')
    sy.draw_partial_opacity(350, 690, 12, music.basic_info.artist, 1, anchor='mm')
    sy.draw_partial_opacity(150, 725, 15, f'Version: {music.basic_info.version}', 1, anchor='lm')
    sy.draw_partial_opacity(550, 725, 15, f'BPM: {music.basic_info.bpm}', 1, anchor='rm')
    for n, i in enumerate(list(map(str, music.ds))):
        if n == 4:
            color = (195, 70, 231, 255)
        else:
            color = (255, 255, 255, 255)
        tb.draw(160 + 95 * n, 814, 25, i, color, 'mm')
    sy.draw(350, 980, 14, f'Modified by Kels_Astell | Generated by {BOTNAME}', (255, 255, 255, 255), 'mm', 1, (159, 81, 220, 255))

    return im


async def solips_play_data(payload: dict):
    payload['version'] = list(set(version for version in plate_to_version.values()))
    data = await get_player_data('plate', payload)

    if isinstance(data, str):
        return data

    player_data: list[dict[str, Union[float, str, int]]] = []
    for i in data['data']['verlist']:
        if i['id'] == 11353:
            player_data.append(i)
    if not player_data:
        return 'ä½ è¿˜æ²¡æœ‰å—¦ğŸ'
    total_ra = 0
    msg = "å—¦æ¢¨ç»Ÿè®¡:\n"
    player_data.sort(key=lambda a: a['level_index'])
    music = mai.total_list.by_id('11353')
    lv_dict = {0: "Basic", 1: "Advanced", 2: "Expert", 3: "Master", 4: "Re:Master"}
    for _data in player_data:
        ds: float = music.ds[_data['level_index']]
        lv: int = _data['level_index']
        ra, rate = computeRa(ds, _data['achievements'], israte=True)
        msg += f"{lv_dict[lv]}éš¾åº¦{rate.replace('p','+')}, æ°äº†{ra}åˆ†.\n"
        if ra >= 321:
            msg += "æˆ‘è¶…, å—¦æ¢¨å¤§ç¥!\n"
        total_ra += ra

    return msg + f"ä½ çš„å—¦æ¢¨æ€»å…±æ¯›åˆ°äº†{total_ra}åˆ†."


async def music_play_data(payload: dict, songs: str):
    payload['version'] = list(set(version for version in plate_to_version.values()))
    data = await get_player_data('plate', payload)
    if isinstance(data, str):
        return data
    #print(data)
    player_data: list[dict[str, Union[float, str, int]]] = []
    for i in data['data']['verlist']:
        if i['id'] == int(songs):
            player_data.append(i)
    player_data.sort(key=lambda a: a['level_index'])
    music = mai.total_list.by_id(songs)

    im = Image.open(os.path.join(maimaidir, 'info_bg.png')).convert('RGBA')
    genre = Image.open(os.path.join(maimaidir, f'info-{category[music.basic_info.genre]}.png'))
    cover = Image.open(await download_music_pictrue(music.id)).resize((210, 210))
    version = Image.open(os.path.join(maimaidir, f'{music.type}.png')).resize((108, 40))

    dr = ImageDraw.Draw(im)
    tb = DrawText(dr, TBFONT)
    sy = DrawText(dr, SIYUAN)

    im.alpha_composite(genre, (45, 145))
    im.alpha_composite(cover, (69, 184))
    im.alpha_composite(version, (725, 360))

    tb.draw(430, 167, 20, music.id, anchor='mm')
    sy.draw(610, 167, 20, music.basic_info.genre, anchor='mm')
    sy.draw(295, 225, 30, music.title, anchor='lm')
    sy.draw(295, 260, 15, f'ä½œæ›²: {music.basic_info.artist}', anchor='lm')
    sy.draw(295, 310, 15, f'BPM: {music.basic_info.bpm}', anchor='lm')
    sy.draw(295, 330, 15, f'ç‰ˆæœ¬: {music.basic_info.version}', anchor='lm')

    y = 120
    TEXT_COLOR = [(14, 117, 54, 255), (199, 69, 12, 255), (175, 0, 50, 255), (103, 20, 141, 255), (103, 20, 141, 255)]
    sss = False
    for _data in player_data:
        ds: float = music.ds[_data['level_index']]
        lv: int = _data['level_index']
        ra, rate = computeRa(ds, _data['achievements'], israte=True)
        if lv >= 3 and rate in ["SSSp","SSS"] and songs in abstract_list:
            sss = True
        rank = Image.open(os.path.join(maimaidir, f'UI_TTR_Rank_{rate}.png')).resize((120, 57))
        im.alpha_composite(rank, (430, 515 + y * lv))
        if _data['fc']:
            fcl = {'fc': 'FC', 'fcp': 'FCp', 'ap': 'AP', 'app': 'APp'}
            fc = Image.open(os.path.join(maimaidir, f'UI_CHR_PlayBonus_{fcl[_data["fc"]]}.png')).resize((76, 76))
            im.alpha_composite(fc, (575, 511 + y * lv))
        if _data['fs']:
            fsl = {'fs': 'FS', 'fsp': 'FSp', 'fsd': 'FSD', 'fsdp': 'FSDp'}
            fs = Image.open(os.path.join(maimaidir, f'UI_CHR_PlayBonus_{fsl[_data["fs"]]}.png')).resize((76, 76))
            im.alpha_composite(fs, (650, 511 + y * lv))

        p, s = f'{_data["achievements"]:.4f}'.split('.')
        r = tb.get_box(p, 36)
        tb.draw(90, 545 + y * lv, 30, str(ds), anchor='mm')
        tb.draw(200, 567 + y * lv, 36, p, TEXT_COLOR[lv], 'ld')
        tb.draw(200 + r[2], 565 + y * lv, 30, f'.{s}%', TEXT_COLOR[lv], 'ld')
        tb.draw(790, 545 + y * lv, 30, ra, TEXT_COLOR[lv], 'mm')

    sy.draw(450, 1180, 20, f'Modified by Kels_Astell | Generated by {BOTNAME}', (159, 81, 220, 255), 'mm', 2, (255, 255, 255, 255))
    if songs in abstract_list:
        comment = random.choice(abstract_list[str(songs)])
    else:
        comment = ''
    return {"sss":sss,"msg":im,"comment":comment}



async def query_chart_data(match: Match) -> str:
    if match.group(1) != '':
        try:
            level_index = level_labels.index(match.group(1))
            level_name = ['Basic', 'Advanced', 'Expert', 'Master', 'Re: MASTER']
            name = match.group(2)
            music = mai.total_list.by_id(name)
            chart = music.charts[level_index]
            ds = music.ds[level_index]
            level = music.level[level_index]
            if len(chart.notes) == 4:
                result = f'''{level_name[level_index]} {level}({ds})
TAP: {chart.notes.tap}
HOLD: {chart.notes.hold}
SLIDE: {chart.notes.slide}
BREAK: {chart.notes.brk}
è°±å¸ˆ: {chart.charter}'''
            else:
                result = f'''{level_name[level_index]} {level}({ds})
TAP: {chart.notes.tap}
HOLD: {chart.notes.hold}
SLIDE: {chart.notes.slide}
TOUCH: {chart.notes.touch}
BREAK: {chart.notes.brk}
è°±å¸ˆ: {chart.charter}'''
            if music.stats and music.stats[level_index]:
                result += f'\næ‹Ÿåˆéš¾åº¦: {music.stats[level_index].fit_diff:.2f}'
            msg = f'''{music.id}. {music.title}
{result}'''
        except:
            msg = randomNotFound()
    else:
        try:
            name = match.group(2)
            music = mai.total_list.by_id(name)
            if music:
                msg = await draw_music_info(music)
            else:
                msg = randomNotFound()

        except Exception as e:
            print(traceback.format_exc())
            msg = randomNotFound()
    
    return msg

async def rise_score_data(payload: dict, match: Match, nickname: Optional[str] = None):
    """
    ä¸Šåˆ†æ•°æ®
    - `payload` : ä¼ é€’ç»™æŸ¥åˆ†å™¨çš„æ•°æ®
    - `match` : æ­£åˆ™ç»“æœ
    - `nickname` : ç”¨æˆ·æ˜µç§°
    """
    dx_ra_lowest = 999
    sd_ra_lowest = 999
    player_dx_list = []
    player_sd_list = []
    music_dx_list = []
    music_sd_list = []

    player_data = await get_player_data('best', payload)

    if isinstance(player_data, str):
        return player_data

    for dx in player_data['charts']['dx']:
        dx_ra_lowest = min(dx_ra_lowest, dx['ra'])
        player_dx_list.append([int(dx['song_id']), int(dx["level_index"]), int(dx['ra'])])
    for sd in player_data['charts']['sd']:
        sd_ra_lowest = min(sd_ra_lowest, sd['ra'])
        player_sd_list.append([int(sd['song_id']), int(sd["level_index"]), int(sd['ra'])])
    player_dx_id_list = [[d[0], d[1]] for d in player_dx_list]
    player_sd_id_list = [[s[0], s[1]] for s in player_sd_list]

    for music in mai.total_list:
        for i, ds in enumerate(music.ds):
            for achievement in realAchievementList[f'{ds:.1f}']:
                if match.group(1) and music['level'][i] != match.group(1): continue
                if f'{achievement:.1f}' == '100.5':
                    index_score = 12
                else:
                    index_score = [index for index, acc in enumerate(achievementList[:-1]) if acc <= achievement < achievementList[index + 1]][0]
                if music.is_new:
                    music_ra = computeRa(ds, achievement)
                    if music_ra < dx_ra_lowest: continue
                    if [int(music.id), i] in player_dx_id_list:
                        player_ra = player_dx_list[player_dx_id_list.index([int(music.id), i])][2]
                        if music_ra - player_ra == int(match.group(2)) and [int(music.id), i, music_ra] not in player_dx_list:
                            music_dx_list.append([music, diffs[i], ds, achievement, scoreRank[index_score + 1].upper(), music_ra])
                    else:
                        if music_ra - dx_ra_lowest == int(match.group(2)) and [int(music.id), i, music_ra] not in player_dx_list:
                            music_dx_list.append([music, diffs[i], ds, achievement, scoreRank[index_score + 1].upper(), music_ra])
                else:
                    music_ra = computeRa(ds, achievement)
                    if music_ra < sd_ra_lowest: continue
                    if [int(music.id), i] in player_sd_id_list:
                        player_ra = player_sd_list[player_sd_id_list.index([int(music.id), i])][2]
                        if music_ra - player_ra == int(match.group(2)) and [int(music.id), i, music_ra] not in player_sd_list:
                            music_sd_list.append([music, diffs[i], ds, achievement, scoreRank[index_score + 1].upper(), music_ra])
                    else:
                        if music_ra - sd_ra_lowest == int(match.group(2)) and [int(music.id), i, music_ra] not in player_sd_list:
                            music_sd_list.append([music, diffs[i], ds, achievement, scoreRank[index_score + 1].upper(), music_ra])

    if len(music_dx_list) == 0 and len(music_sd_list) == 0:
        return 'æ²¡æœ‰æ‰¾åˆ°è¿™æ ·çš„ä¹æ›²'
    elif len(music_dx_list) + len(music_sd_list) > 60:
        return f'ç»“æœè¿‡å¤š({len(music_dx_list) + len(music_sd_list)} æ¡)ï¼Œè¯·ç¼©å°æŸ¥è¯¢èŒƒå›´ã€‚'

    appellation = nickname if nickname else 'æ‚¨'
    msg = ''
    if len(music_sd_list) != 0:
        msg += f'ä¸º{appellation}æ¨èä»¥ä¸‹æ ‡å‡†ä¹æ›²ï¼š\n'
        for music, diff, ds, achievement, rank, ra in sorted(music_sd_list, key=lambda i: int(i[0]['id'])):
            msg += f'{music["id"]}. {music["title"]} {diff} {ds} {achievement} {rank} {ra}\n'
    if len(music_dx_list) != 0:
        msg += f'\nä¸º{appellation}æ¨èä»¥ä¸‹newä¹æ›²ï¼š\n'
        for music, diff, ds, achievement, rank, ra in sorted(music_dx_list, key=lambda i: int(i[0]['id'])):
            msg += f'{music["id"]}. {music["title"]} {diff} {ds} {achievement} {rank} {ra}\n'

    return msg.strip()

async def player_plate_data(payload: dict, match: Match, nickname: Optional[str]):
    song_played = []
    song_remain_basic = []
    song_remain_advanced = []
    song_remain_expert = []
    song_remain_master = []
    song_remain_re_master = []
    song_remain_difficult = []

    data = await get_player_data('plate', payload)

    if isinstance(data, str):
        return data
    if match.group(1) == 'çœŸ':
        verlist = list(filter(lambda x: x['title'] != 'ã‚¸ãƒ³ã‚°ãƒ«ãƒ™ãƒ«', data['verlist']))
    else:
        verlist = data['verlist']
    if match.group(2) in ['å°†', 'è€…']:
        for song in verlist:
            if song['level_index'] == 0 and song['achievements'] < (100.0 if match.group(2) == 'å°†' else 80.0):
                song_remain_basic.append([song['id'], song['level_index']])
            if song['level_index'] == 1 and song['achievements'] < (100.0 if match.group(2) == 'å°†' else 80.0):
                song_remain_advanced.append([song['id'], song['level_index']])
            if song['level_index'] == 2 and song['achievements'] < (100.0 if match.group(2) == 'å°†' else 80.0):
                song_remain_expert.append([song['id'], song['level_index']])
            if song['level_index'] == 3 and song['achievements'] < (100.0 if match.group(2) == 'å°†' else 80.0):
                song_remain_master.append([song['id'], song['level_index']])
            if match.group(1) in ['èˆ', 'éœ¸'] and song['level_index'] == 4 and song['achievements'] < (100.0 if match.group(2) == 'å°†' else 80.0):
                song_remain_re_master.append([song['id'], song['level_index']])
            song_played.append([song['id'], song['level_index']])
    elif match.group(2) in ['æ¥µ', 'æ']:
        for song in verlist:
            if song['level_index'] == 0 and not song['fc']:
                song_remain_basic.append([song['id'], song['level_index']])
            if song['level_index'] == 1 and not song['fc']:
                song_remain_advanced.append([song['id'], song['level_index']])
            if song['level_index'] == 2 and not song['fc']:
                song_remain_expert.append([song['id'], song['level_index']])
            if song['level_index'] == 3 and not song['fc']:
                song_remain_master.append([song['id'], song['level_index']])
            if match.group(1) == 'èˆ' and song['level_index'] == 4 and not song['fc']:
                song_remain_re_master.append([song['id'], song['level_index']])
            song_played.append([song['id'], song['level_index']])
    elif match.group(2) == 'èˆèˆ':
        for song in verlist:
            if song['level_index'] == 0 and song['fs'] not in ['fsd', 'fsdp']:
                song_remain_basic.append([song['id'], song['level_index']])
            if song['level_index'] == 1 and song['fs'] not in ['fsd', 'fsdp']:
                song_remain_advanced.append([song['id'], song['level_index']])
            if song['level_index'] == 2 and song['fs'] not in ['fsd', 'fsdp']:
                song_remain_expert.append([song['id'], song['level_index']])
            if song['level_index'] == 3 and song['fs'] not in ['fsd', 'fsdp']:
                song_remain_master.append([song['id'], song['level_index']])
            if match.group(1) == 'èˆ' and song['level_index'] == 4 and song['fs'] not in ['fsd', 'fsdp']:
                song_remain_re_master.append([song['id'], song['level_index']])
            song_played.append([song['id'], song['level_index']])
    elif match.group(2) == 'ç¥':
        for song in verlist:
            if song['level_index'] == 0 and song['fc'] not in ['ap', 'app']:
                song_remain_basic.append([song['id'], song['level_index']])
            if song['level_index'] == 1 and song['fc'] not in ['ap', 'app']:
                song_remain_advanced.append([song['id'], song['level_index']])
            if song['level_index'] == 2 and song['fc'] not in ['ap', 'app']:
                song_remain_expert.append([song['id'], song['level_index']])
            if song['level_index'] == 3 and song['fc'] not in ['ap', 'app']:
                song_remain_master.append([song['id'], song['level_index']])
            if match.group(1) == 'èˆ' and song['level_index'] == 4 and song['fc'] not in ['ap', 'app']:
                song_remain_re_master.append([song['id'], song['level_index']])
            song_played.append([song['id'], song['level_index']])
    for music in mai.total_list:
        if match.group(1) == 'çœŸ' and music.title == 'ã‚¸ãƒ³ã‚°ãƒ«ãƒ™ãƒ«':
            continue
        if music.basic_info.version in payload['version']:
            if [int(music.id), 0] not in song_played:
                song_remain_basic.append([int(music.id), 0])
            if [int(music.id), 1] not in song_played:
                song_remain_advanced.append([int(music.id), 1])
            if [int(music.id), 2] not in song_played:
                song_remain_expert.append([int(music.id), 2])
            if [int(music.id), 3] not in song_played:
                song_remain_master.append([int(music.id), 3])
            if match.group(1) in ['èˆ', 'éœ¸'] and len(music.level) == 5 and [int(music.id), 4] not in song_played:
                song_remain_re_master.append([int(music.id), 4])
    song_remain_basic = sorted(song_remain_basic, key=lambda i: int(i[0]))
    song_remain_advanced = sorted(song_remain_advanced, key=lambda i: int(i[0]))
    song_remain_expert = sorted(song_remain_expert, key=lambda i: int(i[0]))
    song_remain_master = sorted(song_remain_master, key=lambda i: int(i[0]))
    song_remain_re_master = sorted(song_remain_re_master, key=lambda i: int(i[0]))
    for song in song_remain_basic + song_remain_advanced + song_remain_expert + song_remain_master + song_remain_re_master:
        music = mai.total_list.by_id(str(song[0]))
        if music.ds[song[1]] > 13.6:
            song_remain_difficult.append([music.id, music.title, diffs[song[1]], music.ds[song[1]], song[1]])

    appellation = nickname if nickname else 'æ‚¨'

    msg = f'''{appellation}çš„{match.group(1)}{match.group(2)}å‰©ä½™è¿›åº¦å¦‚ä¸‹ï¼š
åŸºç¡€å‰©ä½™{len(song_remain_basic)}é¦–
é«˜çº§å‰©ä½™{len(song_remain_advanced)}é¦–
ä¸“å®¶å‰©ä½™{len(song_remain_expert)}é¦–
å¤§å¸ˆå‰©ä½™{len(song_remain_master)}é¦–
'''
    song_remain: list[list] = song_remain_basic + song_remain_advanced + song_remain_expert + song_remain_master + song_remain_re_master
    song_record = [[s['id'], s['level_index']] for s in verlist]
    if match.group(1) in ['èˆ', 'éœ¸']:
        msg += f'Re:Masterå‰©ä½™{len(song_remain_re_master)}é¦–\n'
    if len(song_remain_difficult) > 0:
        if len(song_remain_difficult) < 60:
            msg += 'å‰©ä½™å®šæ•°å¤§äº13.6çš„æ›²ç›®ï¼š\n'
            for i, s in enumerate(sorted(song_remain_difficult, key=lambda i: i[3])):
                self_record = ''
                if [int(s[0]), s[-1]] in song_record:
                    record_index = song_record.index([int(s[0]), s[-1]])
                    if match.group(2) in ['å°†', 'è€…']:
                        self_record = str(verlist[record_index]['achievements']) + '%'
                    elif match.group(2) in ['æ¥µ', 'æ', 'ç¥']:
                        if verlist[record_index]['fc']:
                            self_record = comboRank[combo_rank.index(verlist[record_index]['fc'])].upper()
                    elif match.group(2) == 'èˆèˆ':
                        if verlist[record_index]['fs']:
                            self_record = syncRank[sync_rank.index(verlist[record_index]['fs'])].upper()
                msg += f'No.{i + 1} {s[0]}. {s[1]} {s[2]} {s[3]} {self_record}'.strip() + '\n'
            if len(song_remain_difficult) > 10:
                msg = msg.strip()
        else:
            msg += f'è¿˜æœ‰{len(song_remain_difficult)}é¦–å¤§äº13.6å®šæ•°çš„æ›²ç›®ï¼ŒåŠ æ²¹æ¨åˆ†æï¼\n'
    elif len(song_remain) > 0:
        for i, s in enumerate(song_remain):
            m = mai.total_list.by_id(str(s[0]))
            ds = m.ds[s[1]]
            song_remain[i].append(ds)
        if len(song_remain) < 60:
            msg += 'å‰©ä½™æ›²ç›®ï¼š\n'
            for i, s in enumerate(sorted(song_remain, key=lambda i: i[2])):
                m = mai.total_list.by_id(str(s[0]))
                self_record = ''
                if [int(s[0]), s[-1]] in song_record:
                    record_index = song_record.index([int(s[0]), s[-1]])
                    if match.group(2) in ['å°†', 'è€…']:
                        self_record = str(verlist[record_index]['achievements']) + '%'
                    elif match.group(2) in ['æ¥µ', 'æ', 'ç¥']:
                        if verlist[record_index]['fc']:
                            self_record = comboRank[combo_rank.index(verlist[record_index]['fc'])].upper()
                    elif match.group(2) == 'èˆèˆ':
                        if verlist[record_index]['fs']:
                            self_record = syncRank[sync_rank.index(verlist[record_index]['fs'])].upper()
                msg += f'No.{i + 1} {m.id}. {m.title} {diffs[s[1]]} {m.ds[s[1]]} {self_record}'.strip() + '\n'
            if len(song_remain) > 10:
                msg = msg.strip()
        else:
            msg += 'å·²ç»æ²¡æœ‰å®šæ•°å¤§äº13.6çš„æ›²ç›®äº†,åŠ æ²¹æ¸…è°±æï¼\n'
    else:
        msg += f'æ­å–œ{appellation}å®Œæˆ{match.group(1)}{match.group(2)}ï¼'

    return msg

async def level_process_data(payload: dict, match: Match, nickname: Optional[str]):
    song_played = []
    song_remain = []

    data = await get_player_data('plate', payload)

    if isinstance(data, str):
        return data

    if match.group(2).lower() in scoreRank:
        achievement = achievementList[scoreRank.index(match.group(2).lower()) - 1]
        for song in data['verlist']:
            if song['level'] == match.group(1) and song['achievements'] < achievement:
                song_remain.append([song['id'], song['level_index']])
            song_played.append([song['id'], song['level_index']])
    elif match.group(2).lower() in comboRank:
        combo_index = comboRank.index(match.group(2).lower())
        for song in data['verlist']:
            if song['level'] == match.group(1) and ((song['fc'] and combo_rank.index(song['fc']) < combo_index) or not song['fc']):
                song_remain.append([song['id'], song['level_index']])
            song_played.append([song['id'], song['level_index']])
    elif match.group(2).lower() in syncRank:
        sync_index = syncRank.index(match.group(2).lower())
        for song in data['verlist']:
            if song['level'] == match.group(1) and ((song['fs'] and sync_rank.index(song['fs']) < sync_index) or not song['fs']):
                song_remain.append([song['id'], song['level_index']])
            song_played.append([song['id'], song['level_index']])
    for music in mai.total_list:
        for i, lv in enumerate(music.level[2:]):
            if lv == match.group(1) and [int(music.id), i + 2] not in song_played:
                song_remain.append([int(music.id), i + 2])
    song_remain = sorted(song_remain, key=lambda i: int(i[1]))
    song_remain = sorted(song_remain, key=lambda i: int(i[0]))
    songs = []
    for song in song_remain:
        music = mai.total_list.by_id(str(song[0]))
        songs.append([music.id, music.title, diffs[song[1]], music.ds[song[1]], song[1]])

    appellation = nickname if nickname else 'æ‚¨'

    msg = ''
    if len(song_remain) > 0:
        if len(song_remain) < 50:
            song_record = [[s['id'], s['level_index']] for s in data['verlist']]
            msg += f'{appellation}çš„{match.group(1)}å…¨è°±é¢{match.group(2).upper()}å‰©ä½™æ›²ç›®å¦‚ä¸‹ï¼š\n'
            for i, s in enumerate(sorted(songs, key=lambda i: i[3])):
                self_record = ''
                if [int(s[0]), s[-1]] in song_record:
                    record_index = song_record.index([int(s[0]), s[-1]])
                    if match.group(2).lower() in scoreRank:
                        self_record = str(data['verlist'][record_index]['achievements']) + '%'
                    elif match.group(2).lower() in comboRank:
                        if data['verlist'][record_index]['fc']:
                            self_record = comboRank[combo_rank.index(data['verlist'][record_index]['fc'])].upper()
                    elif match.group(2).lower() in syncRank:
                        if data['verlist'][record_index]['fs']:
                            self_record = syncRank[sync_rank.index(data['verlist'][record_index]['fs'])].upper()
                msg += f'No.{i + 1} {s[0]}. {s[1]} {s[2]} {s[3]} {self_record}'.strip() + '\n'
            if len(songs) > 10:
                msg = msg.strip()
        else:
            msg = f'{appellation}è¿˜æœ‰{len(song_remain)}é¦–{match.group(1)}æ›²ç›®æ²¡æœ‰è¾¾æˆ{match.group(2).upper()},åŠ æ²¹æ¨åˆ†æï¼'
    else:
        msg = f'æ­å–œ{appellation}è¾¾æˆ{match.group(1)}å…¨è°±é¢{match.group(2).upper()}ï¼'

    return msg

async def level_achievement_list_data(payload: dict, match: Match, nickname: Optional[str]):
    song_list = []

    data = await get_player_data('plate', payload)

    if isinstance(data, str):
        return data

    for song in data['verlist']:
        if song['level'] == match.group(1):
            song_list.append(song)

    page = max(min(int(match.group(2)), len(song_list) // SONGS_PER_PAGE + 1), 1) if match.group(2) else 1

    appellation = nickname if nickname else 'æ‚¨'

    msg = f'{appellation}çš„{match.group(1)}åˆ†æ•°åˆ—è¡¨ï¼ˆä»é«˜è‡³ä½ï¼‰ï¼š\n'
    for i, s in enumerate(sorted(song_list, key=lambda i: i['achievements'], reverse=True)):
        if (page - 1) * SONGS_PER_PAGE <= i < page * SONGS_PER_PAGE:
            m = mai.total_list.by_id(str(s['id']))
            msg += f'No.{i + 1} {s["achievements"]:.4f} {m.id}. {m.title} {diffs[s["level_index"]]} {m.ds[s["level_index"]]}'
            if s["fc"]: msg += f' {comboRank[combo_rank.index(s["fc"])].upper()}'
            if s["fs"]: msg += f' {syncRank[sync_rank.index(s["fs"])].upper()}'
            msg += '\n'
    msg += f'ç¬¬{page}é¡µï¼Œå…±{len(song_list) // SONGS_PER_PAGE + 1}é¡µ'

    return msg.strip()


def name_linked(kid:str):
    with open(os.path.join(static, 'qq_name_list.json'), 'r', encoding='utf-8') as fp:
        name_list = json.load(fp)
    if kid in name_list:
        return {"success": True, "username": name_list[kid]['id']}
    else:
        return {"success": False}


async def rating_ranking_data(name: Optional[str], page: Optional[int]):

    rank_data = await get_rating_ranking_data()

    if isinstance(rank_data, str):
        return rank_data

    sorted_rank_data = sorted(rank_data, key=lambda r: r['ra'], reverse=True)
    
    if name:
        if name in [r['username'].lower() for r in sorted_rank_data]:
            rank_index = [r['username'].lower() for r in sorted_rank_data].index(name) + 1
            nickname = sorted_rank_data[rank_index - 1]['username']
            ra = sorted_rank_data[rank_index - 1]['ra']
            rank_percent = round(100-rank_index/len(rank_data)*100,2)
            data = ''
            if ra >= 16000:
                data = '\næˆ‘è¶…ï¼Œä¹Œè’™å¤§ç¥ï¼'
            data = data + f'æˆªæ­¢è‡³ {time.strftime("%Yå¹´%mæœˆ%dæ—¥%Hæ—¶%Måˆ†", time.localtime())}\n{nickname}çš„raä¸º{ra}\nåœ¨æ°´é±¼ç½‘ç«™raæ’è¡Œç¬¬{rank_index}\nè¶…è¿‡äº†{rank_percent}%çš„ç©å®¶'
            return data
        else:
            data = 'æœªæ‰¾åˆ°è¯¥ç©å®¶'
            return data
    else:
        user_num = len(sorted_rank_data)
        msg = f'æˆªæ­¢è‡³ {time.strftime("%Yå¹´%mæœˆ%dæ—¥%Hæ—¶%Måˆ†", time.localtime())}ï¼Œæ°´é±¼ç½‘ç«™å·²æ³¨å†Œç”¨æˆ·raæ’è¡Œï¼š\n'
        if page * 50 > user_num:
            page = user_num // 50 + 1
        end = page * 50 if page * 50 < user_num else user_num
        for i, ranker in enumerate(sorted_rank_data[(page - 1) * 50:end]):
            msg += f'{i + 1 + (page - 1) * 50}. {ranker["username"]} {ranker["ra"]}\n'
        msg += f'ç¬¬{page}é¡µï¼Œå…±{user_num // 50 + 1}é¡µ'
        data = msg.strip()

    return data


async def rating_pk(name1: Optional[str], name2: Optional[str]):
    rank_data = await get_rating_ranking_data()

    if isinstance(rank_data, str):
        return rank_data

    sorted_rank_data = sorted(rank_data, key=lambda r: r['ra'], reverse=True)

    if name1 in [r['username'].lower() for r in sorted_rank_data] and name2 in [r['username'].lower() for r in sorted_rank_data]:
        rank_index1 = [r['username'].lower() for r in sorted_rank_data].index(name1) + 1
        rank_index2 = [r['username'].lower() for r in sorted_rank_data].index(name2) + 1
        nickname1 = sorted_rank_data[rank_index1 - 1]['username']
        nickname2 = sorted_rank_data[rank_index2 - 1]['username']
        data = f'{nickname1}åœ¨æ’è¡Œç¬¬{rank_index1}ä½.\n{nickname2}åœ¨æ’è¡Œç¬¬{rank_index2}ä½.\nè®©æˆ‘ä»¬æ­å–œ'
        if not rank_index1 == rank_index2:
            data += f'{nickname1}' if rank_index1 < rank_index2 else f'{nickname2}'
        else:
            data += 'ä¸¤ä½é€‰æ‰‹æ‰“æˆå¹³æ‰‹, ä½ ä»¬å°±æ˜¯ä¼ è¯´ä¸­çš„55å¼€?'
    else:
        data = 'æœªæ‰¾åˆ°è¯¥ç©å®¶'
    return data


def is_abstract(music_id):
    if music_id in abstract_reply:
        rep = abstract_reply[music_id]
        random.shuffle(rep)
        random.shuffle(nls_data)
        return {"abstract":True, "reply":nls_data[0] + rep[0]}
    else:
        return {"abstract":False, "reply":"ä¸çŸ¥é“æ˜¯ä»€ä¹ˆ"}